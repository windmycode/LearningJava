/*
数组的算法：
1、找最值
2、找最值及其下标
3、统计：累加和、平均值等
4、反转
5、复制
6、查找：在数组中，查找某个值是否存在，或者查找某个值的下标
（1）数组中的元素是无序的
	顺序查找
（2）数组中的元素是有序的
	①顺序查找
	②二分查找
7、数组的排序
（1）冒泡排序
（2）直接选择排序
*/
class Test04_SelectSort{
	public static void main(String[] args){
		int[] arr = {4,2,1,8,3};
		
		/*
		直接选择排序：
			经过很多轮
			每一轮，把当前“未排序”的元素中最大/最小的元素及其位置找出来，
			然后与这“最大/最小”值本来/正确的位置的元素进行交换
		也可以理解为直接插入排序
		
		以从小到大为例
		第一轮：
			找出本轮最小的值：1，它的下标[2]
			这个最小值，应该在[0]位置，就交换[2]和[0]位置的元素
			{1,2,4,8,3}
		第二轮：
			找出本轮未排序元素中最小的值：2，它的下标[1]
			这个最小值，应该在[1]位置，就可以不动
		第三轮：
			找出本轮未排序元素中最小的值：3，它的下标[4]
			这个最小值，应该在[2]位置，就交换[4]和[2]位置的元素
			{1,2,3,8,4}
		第四轮：
			找出本轮未排序元素中最小的值：4，它的下标[4]
			这个最小值，应该在[3]位置，就交换[4]和[3]位置的元素
			{1,2,3,4,8}
			
		轮数：长度-1
		*/
		for(int i=0; i<arr.length-1; i++){//总轮数 = 长度-1
			//(1)找出本轮未排序元素中的最小值及其下标
			/*
			第1轮：[0]~[4]范围内最小值及其下标
			第2轮：[1]~[4]范围内最小值及其下标
			第3轮：[2]~[4]范围内最小值及其下标
			第4轮：[3]~[4]范围内最小值及其下标
			
			思路：假设本轮未排序的第一个元素最小，然后用min与本轮后面的元素一一比较
			*/
			int min = arr[i];
			int index = i;
			for(int j = i+1; j<arr.length; j++){
				if(arr[j] < min){
					min = arr[j];
					index = j;
				}
			}
			
			//(2)看这个最小值是否在它应该在的位置
			/*
			第1轮：最小值应该在[0]
			第2轮：最小值应该在[1]
			第3轮：最小值应该在[2]
			第4轮：最小值应该在[3]
			*/
			if(index != i){//交换arr[i]和arr[index]
				int temp = arr[i];
				arr[i] = arr[index];
				arr[index] = temp;
			}
		}
		
		//显示结果
		for(int i=0; i<arr.length; i++){
			System.out.print(arr[i] + " ");
		}
	}
}