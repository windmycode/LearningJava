package com.atguigu.test02;

import java.util.ArrayList;

import org.junit.Test;

/*
 * 泛型：JDK1.5之后引入的
 * 
 * 泛型：泛化的类型，参数化类型
 * 
 * 生活中：
 *   生产瓶子的厂商，只负责生产瓶子，不管你这个瓶子将来用来装什么。
 *   在超市中，大家看到的瓶子上都有标签（商标），表明这个瓶子中是什么。
 *   生产饮料、酒、调料的厂商买回这个瓶子后，在装东西时，就给这个瓶子加上商标（标签）。
 *   
 *   贴上标签后，下次看到时，就知道里面是什么，我可以放心的使用。
 *   
 * Java中：
 * 	  例如：在设计集合这个容器的数据结构时，不知道我们程序员会用它来装什么对象。
 *   可能用它装字符串对象，可能用它装Apple对象....
 *   在设计时不确定元素的类型，但是在使用时，程序员是知道类型的。
 *   现在需要一个方式，渠道，让使用者在使用这个集合等时，告知这个集合我里面装的是什么对象。这就需要泛型。
 *   
 *   现在在设计这个集合时，元素的类型不确定，所以我把这个类型用形参表示，让使用者用实参给我确定这个类型。
 *   因为它代表的是数据的类型，所以把这种形参称为类型形参和类型实参。
 *   泛型：包括类型形参和类型实参
 *   
 * 泛型：<类型>
 * 	例如：<String>,<Integer>.....
 *   
 */
public class TestGeneric {
	
	//方法：求两个整数的和
	//在完成这个功能的时候，不确定，要求的两个整数的值，我通过形参让调用者告诉我整数的值
	//a,b叫做形参，调用时由实参赋值
	//为了区别，把a和b称为数据形参，因为a和b传的是数据值，不是类型
	public int sum(int a, int b){
		return a + b;
	}
	
	@Test
	public void test1(){
		//存本组学员的姓名，String对象
		ArrayList list = new ArrayList();
		list.add("张三");
		list.add("李四");
		list.add("王五");
		list.add(1);
		
		//使用时，不知道我这里面是String类型，统统按照Object
		for (Object object : list) {
			//每次使用元素时，可能需要强转，很麻烦，好比每次打开瓶子，你需要闻一下
			String name = (String) object;//强转有风险
			System.out.println("名字的长度：" + name.length());
		}
	}
}
